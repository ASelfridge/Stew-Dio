<html>
  <head>
    <meta charset="utf-8">
    <title>Basic Example — Networked-Aframe</title>
    <meta name="description" content="Basic Example — Networked-Aframe">

    <script src="js/aframe-v0.8.2.min.js"></script>
    <script src="js/socket.io.min.js"></script>
    <script src="js/easyrtc.js"></script>
    <script src="js/networked-aframe.min.js"></script>
    <script src="js/object-pickup.js"></script>
    <script src="js/object-place.js"></script>
    <script src="js/new-recipe.js"></script>
    <script src="js/tool-component.js"></script>
    <script src="//cdn.rawgit.com/donmccurdy/aframe-physics-system/v3.3.0/dist/aframe-physics-system.min.js"></script>
    
    <script src="https://unpkg.com/aframe-randomizer-components@^3.0.1/dist/aframe-randomizer-components.min.js"></script>
    <script>

      AFRAME.registerComponent('mdmu-parent-constraint', {
        schema: {
            parent:                 {type: "selector", default:null},
            positionOn:             {type: "boolean",  default:true},
            rotationOn:             {type: "boolean",  default:true},
            scaleOn:                {type: "boolean",  default:false},
            positionOffset:         {type: "vec3"},
            rotationOffset:         {type: "vec3"},
            updateRate:             {type:'number', default:10}
        },
        multiple: false, //do not allow multiple instances of this component on this entity
        init: function() {
          this.psuedoParent         = null;
          this.positionOffset       = null;
          this.rotationOffset       = null;
          this.worldMat_Constraint  = new THREE.Matrix4();
          this.position_P           = new THREE.Vector3();
          this.position_C           = new THREE.Vector3();
          this.rotation_P           = new THREE.Quaternion();
          this.rotation_C           = new THREE.Quaternion();
          this.scale_P              = new THREE.Vector3();
          this.scale_C              = new THREE.Vector3();
          this.posMat               = new THREE.Matrix4();
          this.posMat_Off           = new THREE.Matrix4();
          this.rotMat               = new THREE.Matrix4();
          this.rotMat_Off           = new THREE.Matrix4();
          this.scaleMat             = new THREE.Matrix4();
          this.scaleMat_Off         = new THREE.Matrix4();
          this.prevTime             = 0;
        },
        update: function(oldData)  {
            const Context_AF    = this;
            const data = this.data;

            if (Object.keys(data).length === 0) { return; } // No need to update. as nothing here yet

            //model change
            if ( (oldData.parent !== data.parent) && data.parent !== null ) {
                //have to keep checking if everything is ready first ...
                let loopCounter = 0;
                const checkChildParentLoadStatus = () => {
                    if ( data.parent.hasLoaded && Context_AF.el.hasLoaded ) {
                        Context_AF.psuedoParent = data.parent;
                        Context_AF.setupConstraint();
                        clearInterval(constraintLoop);
                    }

                    if (++loopCounter > 20) {
                        console.log( "Warning! : problems setting parentConstraint" );
                        clearInterval(constraintLoop);
                    }
                };
                const constraintLoop = setInterval(checkChildParentLoadStatus, 100);
            }
        },
        setupConstraint: function () {
            console.log('setting up constraint');

            const Context_AF    = this;
            const data = this.data;

            Context_AF.originalPos         = Context_AF.el.object3D.position.clone();
            Context_AF.originalRot         = Context_AF.el.object3D.quaternion.clone();
            Context_AF.originalSca         = Context_AF.el.object3D.scale.clone();
        },
        tick: function(time, timeDelta) {
          if ( time - this.prevTime > this.data.updateRate ) {
            if (this.psuedoParent !== null) {

                this.positionOffset       = this.data.positionOffset;
                this.rotationOffset       = this.data.rotationOffset;
                this.worldMat_Constraint.identity();
                this.position_P.set(0,0,0);
                this.position_C.set(0,0,0);
                this.rotation_P.set(0,0,0,1);
                this.rotation_C.set(0,0,0,1);
                this.scale_P.set(0,0,0);
                this.scale_C.set(0,0,0);
                this.posMat.identity();
                this.posMat_Off.identity();
                this.rotMat.identity();
                this.rotMat_Off.identity();
                this.scaleMat.identity();
                this.scaleMat_Off.identity();

                //get world matrix of pseudo-parent we want to constrain to
                this.worldMat_Constraint.copy( this.psuedoParent.object3D.matrixWorld ); 

                //break down into individual transforms ... thanks for the handy function THREEjs!
                this.worldMat_Constraint.decompose(this.position_P, this.rotation_P, this.scale_P);

                //set matrices
                this.posMat.makeTranslation(this.position_P.x, this.position_P.y, this.position_P.z );
                this.posMat_Off.makeTranslation(this.positionOffset.x, this.positionOffset.y, this.positionOffset.z);
                this.rotMat.makeRotationFromQuaternion(this.rotation_P);
                this.rotMat_Off.makeRotationFromEuler(new THREE.Euler(THREE.Math.DEG2RAD * this.rotationOffset.x, THREE.Math.DEG2RAD * this.rotationOffset.y, THREE.Math.DEG2RAD * this.rotationOffset.z, "XYZ"));
                if ( this.scale_P.length() > Number.EPSILON ) { //zero-vector will throw a bunch of errors here ...
                    this.scaleMat.makeScale(this.scale_P.x, this.scale_P.y, this.scale_P.z);
                }

                //now lets create our new world matrix
                this.worldMat_Constraint.identity();
                this.worldMat_Constraint.scale( this.originalSca  ); //will maintain offset of po, rot, but need to remember scale

                if (this.data.rotationOn) { 
                    this.worldMat_Constraint.premultiply( this.rotMat_Off );
                }
                if (this.data.scaleOn) {
                    this.worldMat_Constraint.premultiply( this.scaleMat_Off );
                }
                if (this.data.positionOn) {
                    this.worldMat_Constraint.premultiply( this.posMat_Off );
                }

                //set matrix copies
                if (this.data.rotationOn) { 
                    this.worldMat_Constraint.premultiply( this.rotMat );
                }
                if (this.data.scaleOn) {
                    this.worldMat_Constraint.premultiply( this.scaleMat );
                }
                if (this.data.positionOn) {
                    this.worldMat_Constraint.premultiply( this.posMat );
                }

                //set new matrix and manually update
                this.invOriginal = new THREE.Matrix4().getInverse(this.el.object3D.matrixWorld);
                this.el.object3D.applyMatrix( this.invOriginal ); //reset this objects matrices
                this.el.object3D.applyMatrix( this.worldMat_Constraint );
            }

            this.prevTime = time;
          }
        },
        remove: function() {
          console.log('removing constraint');
          const Context_AF = this;
          const thisObject3D = Context_AF.el.object3D;

          thisObject3D.position.set(Context_AF.originalPos.x, Context_AF.originalPos.y, Context_AF.originalPos.z);
          thisObject3D.rotation.set(Context_AF.originalRot);
          thisObject3D.scale.set(Context_AF.originalSca.x, Context_AF.originalSca.y, Context_AF.originalSca.z);
        }
      }); 
    </script>
    <script>
      let counter = 0;
    </script>

  </head>
  <body>
    <a-scene networked-scene="room: StewDio; debug: true; connectOnLoad:false;">
      <a-assets>

        <a-asset-item id="ingredientStation_model" src="assets/models/ingredientStation.obj"></a-asset-item>
        <a-asset-item id="interactableIngredient_model" src="assets/models/ingredient.obj"></a-asset-item>
        <a-asset-item id="fryingPan_model" src="assets/models/fryingPan.obj"></a-asset-item>
        <a-asset-item id="table_model" src="assets/models/table.obj"></a-asset-item>
        <a-asset-item id="stove_model" src="assets/models/stove.obj"></a-asset-item>

        <!-- Templates -->

        <!-- Avatar -->
          <template id="avatar-template">
            <a-entity class="avatar">
              <a-sphere class="head"
                color="#5985ff"
                scale="0.45 0.5 0.4"
                random-color
              ></a-sphere>
              </a-entity>
          </template>

          <template id="object-template">
              <a-entity class="syncObj" 
              obj-model="obj:#interactableIngredient_model" 
              material="color: #477725" 
              object-pickup="position: 0.006 -0 -0.156; rotation: 0 0 0;" 
              shadow=""></a-entity>
          </template>

        <!-- SOUNDS  --> 

      </a-assets>



      <!-- ENTITIES -->

        <a-entity id="player" position="0 1.6 0">
          <a-camera id="sceneCamera" networked="template:#avatar-template;attachTemplateToLocal:false;">
              <a-entity id="cursor" cursor="rayOrigin: mouse" position="0 0 -1"></a-entity>
              <a-sphere class="head" visible="false" random-color></a-sphere>
          </a-camera>
        </a-entity>


        <!---------------- LIGHTING ---------------->
        <a-light type="directional" color="#FFBE92" position="35 17.746 -0.69474" intensity="0.5" scale="" light="castShadow:true;shadowCameraFov:60;shadowCameraLeft:-14.07;shadowCameraNear:0;shadowMapHeight:2048;shadowMapWidth:2048"></a-light>            
        <a-light type="ambient" color="white" position="35 5 0" intensity="0.4"></a-light>

         <!-- INGREDIENT STATION-->
         <a-entity 
         id="ingredientStation" 
         obj-model="obj:#ingredientStation_model" 
         position="-3.828 0 11.265" 
         rotation="0 324 0" 
         scale="" 
         shadow=""

         static-body
     ></a-entity>
     <a-entity id='wrapper'>

     </a-entity>
     
     <!-- <a-entity>
      <a-entity id="interactableIngredient" position="-2.509 2.021 11.445" rotation="0 0 0" scale=""  
      networked="template:#object-template;attachTemplateToLocal:true;" 
      >
      </a-entity>
    </a-entity> -->
     <!-- <a-entity 
         id="interactableIngredient"
         class="collidable" 
         obj-model="obj:#interactableIngredient_model" 
         material="color: #477725" 
         position="-2.509 2.021 11.445" 
         rotation="0 0 0" 
         scale="" 
         shadow=""
         
         dynamic-body
         detect-collision

         object-pickup="position: 0.006 -0 -0.156; rotation: 0 0 0"
        ></a-entity>  -->

     <a-entity object-place="hasCollision: true" id="interactableIngredient_placeholder" class="interactableIngredient_placeholder collidable" obj-model="obj:#interactableIngredient_model" visible="false" material="color: red; opacity: 0.2;" position="5.562 3 4.863"  rotation="0 0 0" scale="" shadow="cast:false">
     </a-entity>
       <!-- COOKING AREA -->
       <a-entity id="cookingStation" rotation="0 107.58 0" position="6.08818 0 4.25484"> 

        <a-entity obj-model="obj:#table_model" position="" rotation="" scale="" shadow="">
        </a-entity>

        <a-entity id="stove" obj-model="obj:#stove_model" position="0.04297 -0.34832 -0.16904" rotation="0 180 0" scale="0.8 0.8 0.8" shadow="">
        </a-entity>

        <a-entity 
            id="fryingPan" 
            obj-model="obj:#fryingPan_model" 
            position="-0.356 2.004 -0.561" 
            rotation="0 180 0" 
            scale="0.5 0.5 0.5" 
            shadow=""
            
            tool>
        </a-entity>
        <a-plane static-body id="fryingPanCollisionPlane" position="-0.356 1.9 -0.561" width="1" height="1" rotation="-90 0 0" color="#a5a5a5" shadow></a-plane>

          
        </a-entity>

       


       <!-- GROUND & SKY -->
       <a-plane static-body id="ground" position="0 0 5" width="30" height="30" rotation="-90 0 0" color="#a5a5a5" shadow></a-plane>
            
       <a-sky color="#ECECEC"></a-sky>
       <a-entity   id="sky"
                   geometry="primitive: sphere; radius: 1000"
                   material="shader: flat; src: #skymap; side: back"
                   loadscripts>
       </a-entity>

    </a-scene>

    
    <script>
      // Define custom schema for syncing avatar color, set by random-color
      NAF.schemas.add({
        template: '#avatar-template',
        components: [
          'position',
          'rotation',
          {
            selector: '.head',
            component: 'material',
            property: 'color'
          }
        ]
      });

      NAF.schemas.add({
        template: '#object-template',
        components: [
          'position',
          'rotation',
          
        ]
      });


      function onSceneLoad(){
        let counter = 0;
        
        NAF.connection.subscribeToDataChannel('Player Joined', function(senderId, dataType, data, targetId){
           counter ++;
           console.log("New Player Joined");
           if(counter == 2){
           console.log("Host has began a game");
            let scene = document.querySelector('a-scene');
            let wrapper = document.querySelector('#wrapper');
            let ingredient = document.createElement('a-entity');
            ingredient.setAttribute('id', "interactableIngredient");
            ingredient.setAttribute('position', {x:-2.509, y:2.021, z:11.445});
            ingredient.setAttribute('rotation',  {x:0, y:0, z:0});
            ingredient.setAttribute('networked',  {template:'#object-template', attachTemplateToLocal:true});
            wrapper.appendChild(ingredient);
           }
        });
          document.body.addEventListener('connected', function (evt) {
            console.log('Connected to the server. ClientId =', evt.detail.clientId);
            counter++;
            NAF.connection.broadcastData('Player Joined', counter);
          
        });
        document.body.addEventListener('clientConnected', function (evt) {
            counter++;
            //console.log('Client Connected to the server. ClientId =', evt.detail.clientId);
        });
        
        document.querySelector('a-scene').components['networked-scene'].connect();
        
      }
  
      document.querySelector('a-scene').addEventListener('loaded', onSceneLoad)

     
    </script>
  </body>
</html>
